package com.example.authjwt.impl

import com.example.authjwt.api._
import com.lightbend.lagom.scaladsl.api.transport.{Forbidden, RequestHeader}
import com.lightbend.lagom.scaladsl.server.LocalServiceLocator
import com.lightbend.lagom.scaladsl.testkit.ServiceTest
import org.pac4j.core.context.HttpConstants.{AUTHORIZATION_HEADER, BEARER_HEADER_PREFIX}
import org.scalatest.{AsyncWordSpec, BeforeAndAfterAll, Matchers}

class AuthJwtServiceSpec extends AsyncWordSpec with Matchers with BeforeAndAfterAll {

  // JWT generated by JWTTestDataGenerator
  private val ALICE_SECRET_JWT = "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJBbGljZSIsInJvbGVzIjpbIm1hbmFnZXIiXSwiaXNzIjoiaHR0cHM6XC9cL3BhYzRqLm9yZyIsImlhdCI6MTU0NzIzODgwOCwianRpIjoiMmI1ZmUyYWYtNDI5Yy00M2MyLWEwY2MtMjRmYzk5N2M3YjM5In0.y06Wel1R1oB5lbH-Ay6NEHJvrTNHbBiDwS2x-y7_LiM"
  private val ALICE_SECRET_JWE = "eyJlbmMiOiJBMjU2R0NNIiwiYWxnIjoiZGlyIn0..m-wYjqS77Qhcp18G.tQs3Y-n3GRX1vzkyBW7KRw8nj2HZLZym1IW0qFxDMTeShs9mJDz0jQaOMESnpZG2bI9Fa1N34Z3wFEyU1S03glKvPnTTqTUbzWJGoZ-D70ALuwnueCmT3l3YBnN4yGK_P3D9xyRjdpPeoZMWNMrybTych1DIaFjKkjvedYA.KDiAJQ_xtV3at28gnSYUjw"
  private val ALICE_RSA_JWT = "eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJBbGljZSIsInJvbGVzIjpbIm1hbmFnZXIiXSwiaXNzIjoiaHR0cHM6XC9cL3BhYzRqLm9yZyIsImlhdCI6MTU0NzIzODgwOCwianRpIjoiMmI1ZmUyYWYtNDI5Yy00M2MyLWEwY2MtMjRmYzk5N2M3YjM5In0.EQYEYCN1L8IKLerZ4zhHMbdzI4LkVjo3NPyBxZko_pmtraPXhvRFE1VAYaRLiqEttNPCXXyNKmWDBkpRCE8tPacCGT3XT_s9pLmLBy0EZ4nb0T_TRy4Q1gtJZfcQN-1kbKczs_T_kh2punfiNJGe9CXImcw4HwcCp1GcrRySVng9FmIvE2NAUXex7pGxcYJUVhGOU4Pnboa7lcP0Gz2u4kPIBghE6-vpSEgoeCNeg357_0CUpznYQP9thi5oby-C8-2WFlAx4tashjPojT4SOAMEvbBAWSHSnXwrs1Pf4lJmcVq78QON1TzROmD3CTRA99ANFsqVXFHXpHYZorAdSw"
  private val ALICE_RSA_JWE = "eyJlbmMiOiJBMTI4R0NNIiwiYWxnIjoiUlNBLU9BRVAtMjU2In0.jCz8iRifQrBrHL7rc2oGvgNwxSQzldTD_b9Vx56ZcV5Yi1Skm0ff3GZK5hR1JG1JheVZjGLh3E7iLZDWmt_ghRTSO5uZaNKdziFFGikg_BFC99JtJ7eVRaZWbXe-KVuL2M4pZ5dzC11L1d9QU_8sCqvPVIhVsG6n7kxPDXGrlVpi6mGUmNXEp7GZxYrS3kREwrCsO31CYrw5xiRZDFMIen89ejDwNeZvxxT-JVlVaSDRuYH6UwZhGHBOfknXZeYy_qbAiGX_hWwh3tgyfpZ6tS8fFkq5sM_awzw6T5zo-1dDIZL1gKCs5NFlgBKMqvz0qr-2gJ7LkImOsvCLFwHvkA.UfW_vmxWK1eKzXcZ.VqBWp0lyeZiDuHfC5J1C1SIs6C5oVrs4XJVkLtF2g7IEYoXeNf1CBy0fFGpfjzw7pXHgkg9B_eAnF8Q2OQQ9fDLOvxysjg3v3GCnyoduSRC08E9828jq05aeInn9A5asSkeR9hAaMYiqOlAIY1Bvxp8kigdljeYBurEkSsI.qbI51Vu7z0J57xaT4aCFbA"
  private val ALICE_EC_JWT = "eyJhbGciOiJFUzI1NiJ9.eyJzdWIiOiJBbGljZSIsInJvbGVzIjpbIm1hbmFnZXIiXSwiaXNzIjoiaHR0cHM6XC9cL3BhYzRqLm9yZyIsImlhdCI6MTU0NzIzODgwOCwianRpIjoiMmI1ZmUyYWYtNDI5Yy00M2MyLWEwY2MtMjRmYzk5N2M3YjM5In0.qAaicgjzPiFwIX38srwWPekq2xan-h8xQoW3jvQj5T_d9vUV4yVyPxIFbT_WU8NKeQx1kx8LzUwU5RI8SJyEEw"
  private val ALICE_EC_JWE = "eyJlcGsiOnsia3R5IjoiRUMiLCJjcnYiOiJQLTI1NiIsIngiOiJVX1dBaW4yNGk3WU9iQ1pNdlN2eFVKTjlQWEhuSDVHYXhRMk5lUk42ZS1VIiwieSI6IlVuZWd2VEJkZF9Rb2o2UmZuZlpqcmdEcVpuaTMzT3ZFWlY1Y1cwS1hoY1EifSwiZW5jIjoiQTI1NkdDTSIsImFsZyI6IkVDREgtRVMrQTI1NktXIn0.q_k-_wnNngIwRBUhwFXtpO6B1vzyJnO5mzyemsP3TpCGd-sLcfXwSA.r9xP0LMtss5cO0Vh.BfVYrTx_Y2wwVMvPtQ3kAM7L6AMNBb67J8WZGwngkLiWQqbevYY-_G4ksw_4oPMFxgREYszbn13MatwYIs4tAyGsMJghMJSEpNQ-q_hfNlo5Oxt2s8uGtLL-rfDCxsU3DuAesMApa55QBtcYwA17oB08pY0-J8O92yL_-Kc.l-ngJ4iimTs1Tapqcf_zzg"
  private val BOB_RSA_JWT = "eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJCb2IiLCJyb2xlcyI6WyJkZXZlbG9wZXIiXSwiaXNzIjoiaHR0cHM6XC9cL3BhYzRqLm9yZyIsImlhdCI6MTU0NzIzODgwOCwianRpIjoiM2RkNTU2ZDAtNGFhMC00MWE1LWIxNDctNDZjNDY3NDIwNWZhIn0.KEn3R0Cal7kgzdh5opi7xagAIHLH1lNtypUyjo_25NhfaDXZXYv9kaIqJYZnd3jMUonpPkl72QMP9yRCv88kzBAvSTBMd0SMVlKL0ou1jhRTZyk0AQ8JQhk2ypEyjF385zN9iCrcPab9RFZrLVYqo0SFmkqf1yVp934dfZxcDhPCOOYsWrwsZXd5KK88G19IdSBXCp8zsXl09np92Zz2UWXflrTBNdn4Aedlm5SHLU4zbIKkxeEJVcd_HBQ6NA11VMbxmE9t89505fcJn8ovRhPj5QyORHwDDUFJJZjh1fTVV7-y_aYchJ8YA3GOHdrYgcx0Lr72-Xu5xHnmuHSOYQ"

  private val server = ServiceTest.startServer(
    ServiceTest.defaultSetup.withCluster(false)
  ) { ctx =>
    new AuthJwtApplication(ctx) with LocalServiceLocator
  }

  val service = server.serviceClient.implement[AuthJwtService]

  override protected def afterAll() = server.stop()

  "AuthJwtService::headerJwtAuthenticate" should {
    "authenticate by JWT with RSA signature" in {
      service.headerJwtAuthenticate.handleRequestHeader((header: RequestHeader) => header.withHeader(AUTHORIZATION_HEADER, BEARER_HEADER_PREFIX + ALICE_RSA_JWT)).invoke.map { result =>
        result should ===("Alice")
      }
    }

    "authenticate by JWT with RSA encryption" in {
      service.headerJwtAuthenticate.handleRequestHeader((header: RequestHeader) => header.withHeader(AUTHORIZATION_HEADER, BEARER_HEADER_PREFIX + ALICE_RSA_JWE)).invoke.map { result =>
        result should ===("Alice")
      }
    }

    "authenticate by JWT with Secret signature" in {
      service.headerJwtAuthenticate.handleRequestHeader((header: RequestHeader) => header.withHeader(AUTHORIZATION_HEADER, BEARER_HEADER_PREFIX + ALICE_SECRET_JWT)).invoke.map { result =>
        result should ===("Alice")
      }
    }

    "authenticate by JWT with Secret encryption" in {
      service.headerJwtAuthenticate.handleRequestHeader((header: RequestHeader) => header.withHeader(AUTHORIZATION_HEADER, BEARER_HEADER_PREFIX + ALICE_SECRET_JWE)).invoke.map { result =>
        result should ===("Alice")
      }
    }

    "authenticate by JWT with EC signature" in {
      service.headerJwtAuthenticate.handleRequestHeader((header: RequestHeader) => header.withHeader(AUTHORIZATION_HEADER, BEARER_HEADER_PREFIX + ALICE_EC_JWT)).invoke.map { result =>
        result should ===("Alice")
      }
    }

    "authenticate by JWT with EC encryption" in {
      service.headerJwtAuthenticate.handleRequestHeader((header: RequestHeader) => header.withHeader(AUTHORIZATION_HEADER, BEARER_HEADER_PREFIX + ALICE_EC_JWE)).invoke.map { result =>
        result should ===("Alice")
      }
    }
  }

  "AuthJwtService::headerJwtAuthorize" should {
    "authenticate manager Alice" in {
      service.headerJwtAuthorize.handleRequestHeader((header: RequestHeader) => header.withHeader(AUTHORIZATION_HEADER, BEARER_HEADER_PREFIX + ALICE_RSA_JWT)).invoke.map { result =>
        result should ===("Alice")
      }
    }
    "not authenticate developer Bob" in {
      recoverToSucceededIf[Forbidden] {
        service.headerJwtAuthorize.handleRequestHeader((header: RequestHeader) => header.withHeader(AUTHORIZATION_HEADER, BEARER_HEADER_PREFIX + BOB_RSA_JWT)).invoke
      }
    }
  }
}
